[{"body":"Nifty is a simple and easy language to get started with. Let's go!\nDownloading Nifty Download nifty for your platform here.\nIf you want to build and install nifty yourself see the README in the repo for instructions.\nSyntax Highlighting We have a plugin for Visual Studio Code that will make developing nifty programs nicer. Search for an extension called nifty-lang and install it. There is also a vim theme available on github as well.\nHello World Once everything is installed let's make a simple nifty program to make sure it's installed correctly.\n1mkdir hello 2cd hello 3nifty new Nifty will generate a file called build.toml and a file called hello.nifty which should look like this:\n1package hello 2 3using \u0026lt;fmt\u0026gt; 4 5fn main() { 6 println(\u0026#34;Hullo!\u0026#34;) 7} To build and run the project use:\n1nifty run hello This will build and then run the hello target in build.toml.\nBecause hello is the default target in the project you can also run it with:\n1nifty run Or even just:\n1nifty By default nifty will try to build and run the default target in build.toml when called.\nIf you just want to build the project use:\n1nifty build hello ","link":"https://example.com/docs/nifty/","section":"docs","title":"Getting Started"},{"body":"These docs consists of two parts:\nThe nifty programming language. The nifty standard library (nsl). The first section is about the language itself and contains little information on the nsl.\nThe second section is documentation on the nsl and contains little information on the language.\nNifty Docs NSL Docs ","link":"https://example.com/docs/","section":"docs","title":"Nifty"},{"body":"Just an example of an additional docs folder.\nSurprised that it doesn't have a left sidebar menu? Worry not; just follow this instructions to enable it.\nTutorials Back to docs ","link":"https://example.com/tutorials/","section":"tutorials","title":"Tutorials' Docs"},{"body":"Variables in nifty work a little bit differently than in other languages.\nVariables Variables are declared with the let keyword.\n1let x: int = 12 The types can be inferred.\n1let x = 12 // x is an int. 2let y = someFunc() The variable declaration operator can be used as well.\n1a := 12 // x is an int. 2b := 12.f // b is a float/f32. 3c := 12.0 // c is a float/f32. 4d := 12.d // d is a double/f64. By default variables in nifty are initialized to their zero value.\n1let x: int // x is 0. Variables can be explicitly be uninitialized with the undefined keyword or with #noAutoInit.\n1let a: int = undefined 2#noAutoInit { 3 let x: int 4 let y: float 5 let z: string 6} 7b := a // Valid, but undefined behavior. Undefined can only be used for declaration.\n1let x = 12 2x = undefined // Invalid! 3if (x == undefined) // Invalid! Nifty does not support variable shadowing.\n1let x: int 2{ 3 let x: float // Invalid! 4} Runtime Constants Runtime constants are declared with the 'val' keyword.\n1val x: int = 12 Type infence can be used as well.\n1val x = 12 2val y = someFunc() The constant declaration operator can be used as well.\n1x ::= 12 2y ::= someFunc() The undefined keyword can't be used with constants. Constants do not have zero values and their values must be specified.\n1val x: int = undefined // Invalid! 2val y: int // Invalid! Compiletime Constants Compiletime constants are declared with the const keyword and their value must be known at compiletime. Type inference works with compiletime consts and the constant declaration operator can be used with compiletime consts. The compiler will decide if something is a runtime or compiletime const so the same operator can be used.\n1const x: int = 12 2const y = someFunc() // Invalid! 3const z = 42 4const a = #SOME_MACRO_CONST 5b ::= 19 Unused If a function returns two or more variables and you don't care about all of them you can use unused.\n1x, unused := someFunc() 2unused, y := someFunc() If a function is marked with #[useReturn] then unused can be used to ignore the result.\n1unused := useReturnFunc() unused can't be a constant.\n1unused ::= someFunc() // Invalid! unused is not a real variable.\n1x := unused // Invalid! 2fmt::println(unused) // Invalid! 3type_of(unused) // Invalid! ","link":"https://example.com/docs/nifty/variables/","section":"docs","title":"Variables"},{"body":"Basic Types 1char // same as u32 defaults to \u0026#39;\\0\u0026#39; 2int // same as s32 defaults to 0 3uint // same as u32 defaults to 0 4float // same as f32 defaults to 0.f 5double // same as f64 defaults to 0.d 6 7uintptr // defaults to 0 8 9// defaults to false 10bool b8 b16 b32 b64 11 12// defaults to 0 13u8 u16 u32 u64 u128 14s8 s16 s32 s64 s128 15 16//defaults to 0.0 17f16 f32 f64 f128 18 19//defaults to \u0026#34;\u0026#34; 20string 21 22// defaults to \u0026#34;\\0\u0026#34; 23cstring // Null terminated string. Meant for interfacing with c libraries. 24 25typeid // runtime identifier for a type. 26 27rawptr // Like void* in c, used for compatibility with existing c code. Type Aliases Type aliases can be created with the type ... as pattern.\n1type Month as int To force a type alias to be distinct, use the distinct attribute.\n1#[distinct] type Month as int ","link":"https://example.com/docs/nifty/types/","section":"docs","title":"Types"},{"body":"\rNifty Programming Language Nifty is a new systems programming language in development. Nifty aims to be simple, efficient, and enjoyable to use.\nNifty strives for adequacy and will settle for nothing less (eventually).\nNifty tip\nUse nifty help for help!\nGetting StartedDownload Nifty\n","link":"https://example.com/","section":"","title":"About"},{"body":"","link":"https://example.com/categories/","section":"categories","title":"Categories"},{"body":"","link":"https://example.com/tags/","section":"tags","title":"Tags"}]